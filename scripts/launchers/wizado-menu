#!/usr/bin/env python3
import curses
import os
import subprocess
import sys
import json
import re

CONFIG_FILE = os.path.expanduser("~/.gaming-mode.conf")
HYPR_INCLUDE_FILE = os.path.expanduser("~/.config/hypr/conf.d/wizado.conf")

VENDOR_NAMES = {
    "0x10de": "NVIDIA",
    "0x1002": "AMD",
    "0x8086": "Intel",
}

def load_config():
    config = {}
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            for line in f:
                if '=' in line:
                    key, val = line.strip().split('=', 1)
                    config[key] = val.strip('"').strip("'")
    return config

def save_config(config):
    lines = []
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            lines = f.readlines()
    
    # Update existing keys
    new_lines = []
    seen_keys = set()
    for line in lines:
        if '=' in line:
            key = line.split('=', 1)[0].strip()
            if key in config:
                new_lines.append(f'{key}="{config[key]}"\n')
                seen_keys.add(key)
                continue
        new_lines.append(line)
    
    # Add new keys
    for key, val in config.items():
        if key not in seen_keys:
            new_lines.append(f'{key}="{val}"\n')
            
    with open(CONFIG_FILE, 'w') as f:
        f.writelines(new_lines)

def get_display_info():
    try:
        # Try to use hyprctl to get current monitor info
        output = subprocess.check_output(["hyprctl", "monitors", "-j"], stderr=subprocess.DEVNULL)
        data = json.loads(output)
        if data:
            # Get the focused monitor or the first one
            monitor = next((m for m in data if m.get("focused")), data[0])
            return monitor["width"], monitor["height"], monitor["refreshRate"]
    except Exception:
        pass
    return 1920, 1080, 60

def _read_text(path: str) -> str:
    try:
        with open(path, "r") as f:
            return f.read().strip()
    except Exception:
        return ""

def _card_sysfs_info(dev_node: str):
    # dev_node like /dev/dri/card1
    card = os.path.basename(os.path.realpath(dev_node))
    base = f"/sys/class/drm/{card}/device"
    vendor = _read_text(os.path.join(base, "vendor"))
    device = _read_text(os.path.join(base, "device"))
    return card, vendor, device

def _pci_pretty_name(pci_addr: str) -> str:
    # Best-effort: lspci -s 0000:01:00.0 -nn
    try:
        out = subprocess.check_output(["lspci", "-s", pci_addr, "-nn"], stderr=subprocess.DEVNULL).decode("utf-8", errors="replace").strip()
        # Strip leading PCI address if present
        return re.sub(r"^[0-9a-fA-F:.]+\\s+", "", out)
    except Exception:
        return ""

def list_drm_cards():
    cards = []
    by_path = "/dev/dri/by-path"
    if not os.path.isdir(by_path):
        return cards

    for name in sorted(os.listdir(by_path)):
        if not name.endswith("-card"):
            continue
        by_path_node = os.path.join(by_path, name)
        real_node = os.path.realpath(by_path_node)
        # pci-0000:01:00.0-card
        m = re.match(r"^pci-(.+)-card$", name)
        pci_addr = m.group(1) if m else ""
        card, vendor, device = _card_sysfs_info(real_node)
        ven_dev = ""
        if vendor and device:
            ven_dev = f"{vendor[2:]}:{device[2:]}".lower() if vendor.startswith("0x") and device.startswith("0x") else f"{vendor}:{device}"
        vendor_name = VENDOR_NAMES.get(vendor.lower(), vendor or "Unknown")
        pretty = _pci_pretty_name(pci_addr) if pci_addr else ""
        cards.append({
            "by_path": by_path_node,
            "real": real_node,
            "card": card,
            "pci": pci_addr,
            "vendor": vendor,
            "device": device,
            "vendor_name": vendor_name,
            "ven_dev": ven_dev,
            "pretty": pretty,
        })
    return cards

def draw_menu(stdscr, title, options, current_selection):
    stdscr.clear()
    h, w = stdscr.getmaxyx()
    
    # Draw title box
    box_w = 70
    box_h = len(options) + 6
    start_y = (h - box_h) // 2
    start_x = (w - box_w) // 2
    
    # Draw title
    title_str = f" {title} "
    stdscr.addstr(start_y + 1, start_x + (box_w - len(title_str)) // 2, title_str, curses.A_BOLD)
    
    # Draw separator
    stdscr.hline(start_y + 3, start_x + 2, curses.ACS_HLINE, box_w - 4)

    # Draw options
    for idx, (label, desc) in enumerate(options):
        x = start_x + 4
        y = start_y + 5 + idx
        if idx == current_selection:
            stdscr.attron(curses.A_REVERSE)
            stdscr.addstr(y, x, f"> {label:<25} | {desc}")
            stdscr.attroff(curses.A_REVERSE)
        else:
            stdscr.addstr(y, x, f"  {label:<25} | {desc}")
            
    # Draw footer
    footer = "↑↓ navigate • enter submit"
    stdscr.addstr(start_y + box_h - 2, start_x + 4, footer, curses.A_DIM)
    
    stdscr.refresh()

def get_input(stdscr, prompt, default_val=""):
    curses.echo()
    curses.curs_set(1)
    h, w = stdscr.getmaxyx()
    
    # Input box
    box_w = 60
    box_h = 5
    start_y = (h - box_h) // 2
    start_x = (w - box_w) // 2
    
    win = curses.newwin(box_h, box_w, start_y, start_x)
    win.box()
    win.addstr(1, 2, prompt)
    win.addstr(2, 2, "Current: " + default_val)
    win.addstr(3, 2, "> ")
    win.refresh()
    
    # Simple input
    inp = win.getstr(3, 4, 50).decode('utf-8')
    
    curses.noecho()
    curses.curs_set(0)
    return inp.strip()

def get_keybindings():
    bindings = {
        "nested": {"key": "SUPER SHIFT, S", "cmd": "enter-gamesmode --mode nested"},
        "performance": {"key": "SUPER ALT, S", "cmd": "enter-gamesmode --mode performance"},
        "exit":   {"key": "SUPER SHIFT, R", "cmd": "leave-gamesmode"}
    }
    
    if not os.path.exists(HYPR_INCLUDE_FILE):
        return bindings

    with open(HYPR_INCLUDE_FILE, 'r') as f:
        for line in f:
            # Match bindd = MODS, KEY, DESC, exec, CMD
            # or bind = MODS, KEY, exec, CMD
            if "enter-gamesmode --mode nested" in line:
                m = re.search(r'bindd?\s*=\s*([^,]+,\s*[^,]+),', line)
                if m: bindings["nested"]["key"] = m.group(1).strip()
            elif "enter-gamesmode --mode performance" in line or "enter-gamesmode --mode tty" in line:
                m = re.search(r'bindd?\s*=\s*([^,]+,\s*[^,]+),', line)
                if m: bindings["performance"]["key"] = m.group(1).strip()
            elif "leave-gamesmode" in line:
                m = re.search(r'bindd?\s*=\s*([^,]+,\s*[^,]+),', line)
                if m: bindings["exit"]["key"] = m.group(1).strip()
    return bindings

def save_keybindings(bindings):
    # We will regenerate the file with the new keys but keep the commands
    script_dir = os.path.dirname(os.path.abspath(__file__))
    switch_bin = os.path.join(script_dir, "enter-gamesmode")
    return_bin = os.path.join(script_dir, "leave-gamesmode")
    
    content = f"""# wizado Hyprland bindings (Omarchy 3.2)
# Generated by wizado-menu
unbind = {bindings['nested']['key']}
unbind = {bindings['performance']['key']}
unbind = {bindings['exit']['key']}
bindd = {bindings['nested']['key']}, Steam (nested), exec, {switch_bin} --mode nested --steam-ui normal
bindd = {bindings['performance']['key']}, Steam (performance), exec, {switch_bin} --mode performance --steam-ui bigpicture
bindd = {bindings['exit']['key']}, Exit Couch Mode, exec, {return_bin}
"""
    try:
        with open(HYPR_INCLUDE_FILE, 'w') as f:
            f.write(content)
        subprocess.run(["hyprctl", "reload"], stderr=subprocess.DEVNULL)
        return True
    except Exception:
        return False

def keybindings_menu(stdscr):
    selection = 0
    while True:
        bindings = get_keybindings()
        options = [
            ("Start (Nested)",       bindings["nested"]["key"]),
            ("Start (Performance)",  bindings["performance"]["key"]),
            ("Stop / Exit",       bindings["exit"]["key"]),
            ("Back",              "Return to main menu")
        ]
        
        draw_menu(stdscr, "Keybindings Configuration", options, selection)
        key = stdscr.getch()
        
        if key == curses.KEY_UP:
            selection = (selection - 1) % len(options)
        elif key == curses.KEY_DOWN:
            selection = (selection + 1) % len(options)
        elif key == 10: # Enter
            choice = options[selection][0]
            if choice == "Back":
                return
            
            target = ""
            if "Nested" in choice: target = "nested"
            elif "Performance" in choice: target = "performance"
            elif "Stop" in choice: target = "exit"
            
            new_key = get_input(stdscr, f"Enter new binding for {choice}:", bindings[target]["key"])
            if new_key:
                bindings[target]["key"] = new_key
                save_keybindings(bindings)
                # Show confirmation?
                msg = curses.newwin(3, 40, 10, 10)
                msg.box()
                msg.addstr(1, 2, "Saved & Reloaded Hyprland!")
                msg.refresh()
                curses.napms(1000)

def resolution_menu(stdscr):
    dw, dh, dr = get_display_info()
    
    # Define resolution options based on current display
    # Logic: Always offer Native, 1080p, 720p. If 4K, offer 1440p.
    
    options = []
    
    # Native / Auto
    options.append(("Auto / Native", f"Use detected resolution ({dw}x{dh})"))

    # Upscaling presets based on native res
    if dw == 3840 and dh == 2160:
        options.append(("UHD Upscaled", "Render at 1440p, upscale to 4K (balanced)"))
        options.append(("1440p Upscaled", "Render at 1080p, upscale to 1440p (better FPS)")) 
    elif dw == 2560 and dh == 1440:
        options.append(("1440p Upscaled", "Render at 1080p, upscale to 1440p (better FPS)"))
    
    # Standard options if not already covered
    if (dw, dh) != (2560, 1440):
         options.append(("1440p (2560x1440)", "Render at 1440p resolution"))
         
    if (dw, dh) != (1920, 1080):
        options.append(("1080p (1920x1080)", "Render at 1080p resolution"))
        
    if (dw, dh) != (1280, 720):
        options.append(("720p (1280x720)", "Render at 720p resolution"))
        
    options.append(("Back", "Return to main menu"))
    
    selection = 0
    
    while True:
        draw_menu(stdscr, f"Gaming Mode - Resolution Settings (Display: {dw}x{dh})", options, selection)
        key = stdscr.getch()
        
        if key == curses.KEY_UP:
            selection = (selection - 1) % len(options)
        elif key == curses.KEY_DOWN:
            selection = (selection + 1) % len(options)
        elif key == 10: # Enter
            choice = options[selection][0]
            if choice == "Back":
                return
            
            config = load_config()
            
            if choice == "Auto / Native":
                # Clear resolution settings to let enter-gamesmode auto-detect
                if "GAMESMODE_INTERNAL_W" in config: del config["GAMESMODE_INTERNAL_W"]
                if "GAMESMODE_INTERNAL_H" in config: del config["GAMESMODE_INTERNAL_H"]
                save_config(config)
                return

            # Parse choice
            w, h = 0, 0
            if choice == "UHD Upscaled":
                w, h = 2560, 1440
            elif choice == "1440p Upscaled":
                w, h = 1920, 1080
            elif "x" in choice and not "Upscaled" in choice:
                # Extract resolution from string like "3840x2160" or "1080p (1920x1080)"
                import re
                m = re.search(r'(\d+)x(\d+)', choice)
                if m:
                    w, h = int(m.group(1)), int(m.group(2))
            
            if w and h:
                # config already loaded above
                config["GAMESMODE_INTERNAL_W"] = str(w)
                config["GAMESMODE_INTERNAL_H"] = str(h)
                save_config(config)
                return

def performance_gpu_menu(stdscr):
    config = load_config()
    current = config.get("PERFORMANCE_DRM_DEVICE", "")
    cards = list_drm_cards()

    options = []
    if not cards:
        options = [
            ("No DRM cards found", "/dev/dri/by-path not present"),
            ("Back", "Return to Settings"),
        ]
        selection = 0
        while True:
            draw_menu(stdscr, "Performance GPU (TTY)", options, selection)
            key = stdscr.getch()
            if key == curses.KEY_UP:
                selection = (selection - 1) % len(options)
            elif key == curses.KEY_DOWN:
                selection = (selection + 1) % len(options)
            elif key == 10:
                return

    # Build menu options; keep labels short
    for c in cards:
        is_selected = (current == c["by_path"]) or (current == c["real"])
        marker = "*" if is_selected else " "
        pci_short = c["pci"].replace("0000:", "") if c["pci"] else c["card"]
        label = f"{marker} {c['vendor_name']} {pci_short}"
        desc_parts = []
        if c["ven_dev"]:
            desc_parts.append(c["ven_dev"])
        if c["pretty"]:
            desc_parts.append(c["pretty"])
        desc_parts.append(c["by_path"])
        options.append((label, " • ".join(desc_parts)[:80]))
    options.append(("Back", "Return to Settings"))

    # Default selection: current if set; else first entry
    selection = 0
    if current:
        for i, c in enumerate(cards):
            if current == c["by_path"] or current == c["real"]:
                selection = i
                break

    while True:
        draw_menu(stdscr, "Performance GPU (TTY)", options, selection)
        key = stdscr.getch()
        if key == curses.KEY_UP:
            selection = (selection - 1) % len(options)
        elif key == curses.KEY_DOWN:
            selection = (selection + 1) % len(options)
        elif key == 10:
            choice = options[selection][0]
            if choice == "Back":
                return

            chosen = cards[selection]
            config["PERFORMANCE_DRM_DEVICE"] = chosen["by_path"]
            if chosen.get("ven_dev"):
                config["PERFORMANCE_VK_DEVICE"] = chosen["ven_dev"]
            save_config(config)

            msg = curses.newwin(4, 70, 4, 4)
            msg.box()
            msg.addstr(1, 2, "Saved Performance GPU selection:")
            msg.addstr(2, 2, f"{chosen['vendor_name']} {chosen.get('pretty','')}".strip()[:66])
            msg.refresh()
            curses.napms(1200)
            return

def settings_menu(stdscr):
    selection = 0
    options = [
        ("Resolution", "Internal render resolution / upscaling presets"),
        ("Performance GPU", "Choose which GPU drives the TTY session (WLR_DRM_DEVICES)"),
        ("Back", "Return to main menu"),
    ]
    while True:
        draw_menu(stdscr, "Settings", options, selection)
        key = stdscr.getch()
        if key == curses.KEY_UP:
            selection = (selection - 1) % len(options)
        elif key == curses.KEY_DOWN:
            selection = (selection + 1) % len(options)
        elif key == 10:
            choice = options[selection][0]
            if choice == "Back":
                return
            if choice == "Resolution":
                resolution_menu(stdscr)
            elif choice == "Performance GPU":
                performance_gpu_menu(stdscr)

def main_menu(stdscr):
    curses.curs_set(0)
    curses.start_color()
    # curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    
    options = [
        ("Launch (Nested)",      "Gamescope under Hyprland (fast start)"),
        ("Launch (Performance)", "Exclusive TTY gamescope session (max GPU focus)"),
        ("Settings",             "Configure Resolution & Options"),
        ("Keybindings",          "View/Edit Start & Stop Shortcuts"),
        ("Exit",                 "Exit Menu")
    ]
    selection = 0
    
    while True:
        draw_menu(stdscr, "Wizado Gaming Mode", options, selection)
        key = stdscr.getch()
        
        if key == curses.KEY_UP:
            selection = (selection - 1) % len(options)
        elif key == curses.KEY_DOWN:
            selection = (selection + 1) % len(options)
        elif key == 10: # Enter
            if selection == 0: # Launch Nested
                curses.endwin()
                script_dir = os.path.dirname(os.path.abspath(__file__))
                launcher = os.path.join(script_dir, "enter-gamesmode")
                subprocess.run([launcher, "--mode", "nested", "--steam-ui", "normal"])
                sys.exit(0)
            elif selection == 1: # Launch Performance
                curses.endwin()
                script_dir = os.path.dirname(os.path.abspath(__file__))
                launcher = os.path.join(script_dir, "enter-gamesmode")
                subprocess.run([launcher, "--mode", "performance", "--steam-ui", "bigpicture"])
                sys.exit(0)
            elif selection == 2: # Settings
                settings_menu(stdscr)
            elif selection == 3: # Keybindings
                keybindings_menu(stdscr)
            elif selection == 4: # Exit
                return

if __name__ == "__main__":
    try:
        curses.wrapper(main_menu)
    except KeyboardInterrupt:
        pass
